import category
import adjunctions.homset
import functors.right_product
import functors.exponentiation

namespace category_theory

def rproduct_exponentiation_adjoint {ğ’ : category} [has_all_products ğ’] [has_exponentiation ğ’] (c : ğ’)
: adjunction_hom (r_product_functor c) (exponentiation_functor c) :=
{
  Ï† :=
  -- Ï† maps a morphism h : aÃ—c â†’ b to a morphism h' : a â†’ b^c
  -- But there is a unique morphism mapping, according to 
  -- exponentiation's universal property.
    begin
      intros a b h,
      exact (exp b c).ue a h,
    end,
  Ï†r :=
  -- Ï†r maps a morphism h' : a â†’ b^c to a morphism h : aÃ—c â†’ b.
  -- That's the other path in the universal diagram, by composing
  -- the evaluation arrow with h'Ã—Id_c.
    begin
      intros a b h',
      exact ğ’.compose (exp b c).ev (product_morphism h' (ğ’.id c)),
    end,
  sect :=
  -- Ï† is isomorphic (preserves structure)
  -- to prove: (Ï† âˆ˜ Ï†r) âˆ˜ h = h
  -- that is, h' : a â†’ b^c is the unique arrow generated by the
  -- universal property, when going from aÃ—c to b via ev_b^c âˆ˜ h'Ã—Id_c.
  -- We can use this with the uniqueness property of exponentiation.
    begin
      intros a b h',
      simp,
      symmetry,
      apply (exp b c).uu a (ğ’.compose (exp b c).ev (product_morphism h' (ğ’.id c))) h',
      refl,
    end,
  retr :=
  -- Ï†r is isomorphic
  -- This is exactly exponentiation's ump.
    begin
      intros a b h,
      simp,
      symmetry,
      exact (exp b c).ump a h,
    end,
  --              Ï†
  --   C(aÃ—c,  b) â†’ C(a,  b^c)
  --
  --   (âˆ˜ kÃ—Id_c) â†“        â†“ (âˆ˜k) commutes
  --
  --   C(xÃ—c, b) â†’ C(x, b^c)
  --              Ï†
  naturality_c :=
    begin
      intros a b h x k,
      have q : (r_product_functor c).map_hom k = product_morphism k (ğ’.id c) := by refl,
      rw q,
      -- via uniqueness property, this is equiv. to proving
      -- h âˆ˜ kÃ—Id_c =  ev_b^c âˆ˜ (h_ue âˆ˜ k)Ã—Id_c
      apply (exp b c).uu,
      -- by ump for h, h = ev_b^c âˆ˜ h_ueÃ—Id_c
      rw (exp b c).ump a h,
      rw â† ğ’.assoc,
      apply simp_comp_right,
      -- goal is now ue_hÃ—Id_c âˆ˜ kÃ—Id_c = (ue_(ev_b^c âˆ˜ ue_hÃ—Id_c) âˆ˜ k)Ã—Id_c
      -- via gÃ—g' âˆ˜ fÃ—f' = (gâˆ˜f)Ã—(g'âˆ˜f'), we change this to
      -- (ue_h âˆ˜ k)Ã—(Id_c âˆ˜ Id_c) = (ue_(ev_b^c âˆ˜ ue_hÃ—Id_c) âˆ˜ k)Ã—Id_c
      rw refl_product_morphism_compose,
      apply simp_product_morphism,
      split,
      -- prove left side, ue_h âˆ˜ k = ue_(ev_b^c âˆ˜ ue_hÃ—Id_c) âˆ˜ k
      apply simp_comp_left,
      -- equivalent to ue_h = ue_(ev_b^c âˆ˜ ue_hÃ—Id_c), which is just ump
      rw â† (exp b c).ump a h,
      -- prove right side, trivial Id_c âˆ˜ Id_c = Id_c
      rw ğ’.left_id,
    end,
  naturality_d :=
    begin
      intros a b h x k,
      have q : (exponentiation_functor c).map_hom k = exp_hom c k := by refl,
      rw q,
      -- via uniqueness property, and then do some shifting around
      unfold exp_hom,
      apply (exp x c).uu,
      rw â† exp_hom,
      rw â† ğ’.left_id (ğ’.id c),
      rw â† refl_product_morphism_compose,
      rw ğ’.assoc,
      rw simp_exp_hom,
      rw â† ğ’.assoc,
      rw simp_comp_right,
      -- this is exactly wht we get from the ump
      rw â† (exp b c).ump,
    end,
  naturality_cr :=
    begin
      intros a b h x k,
      have q : (r_product_functor c).map_hom k = product_morphism k (ğ’.id c) := by refl,
      rw q,
      rw â† ğ’.assoc,
      rw refl_product_morphism_compose,
      rw ğ’.left_id,
    end,
  naturality_dr :=
    begin
      intros a b h x k,
      have q : (exponentiation_functor c).map_hom k = exp_hom c k := by refl,
      rw q,
      rw ğ’.assoc,
      rw â† simp_exp_hom,
      rw â† ğ’.assoc,
      rw simp_comp_right,
      rw refl_product_morphism_compose,
      rw ğ’.left_id,
    end,
}

end category_theory