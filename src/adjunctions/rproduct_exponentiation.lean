import category
import adjunctions.homset
import functors.right_product
import functors.exponentiation

namespace category_theory

def rproduct_exponentiation_adjoint {C : category} [has_all_products C] [has_exponentiation C] (c : C)
: adjunction_hom (r_product_functor c) (exponentiation_functor c) :=
{
  φ :=
  -- φ maps a morphism h : a×c → b to a morphism h' : a → b^c
  -- But there is a unique morphism mapping, according to 
  -- exponentiation's universal property.
    begin
      intros a b h,
      exact (exp b c).ue a h,
    end,
  φr :=
  -- φr maps a morphism h' : a → b^c to a morphism h : a×c → b.
  -- That's the other path in the universal diagram, by composing
  -- the evaluation arrow with h'×Id_c.
    begin
      intros a b h',
      exact C.compose (exp b c).ev (product_morphism h' (C.id c)),
    end,
  sect :=
  -- φ is isomorphic (preserves structure)
  -- to prove: (φ ∘ φr) ∘ h = h
  -- that is, h' : a → b^c is the unique arrow generated by the
  -- universal property, when going from a×c to b via ev_b^c ∘ h'×Id_c.
  -- We can use this with the uniqueness property of exponentiation.
    begin
      intros a b h',
      simp,
      symmetry,
      apply (exp b c).uu a (C.compose (exp b c).ev (product_morphism h' (C.id c))) h',
      refl,
    end,
  retr :=
  -- φr is isomorphic
  -- This is exactly exponentiation's ump.
    begin
      intros a b h,
      simp,
      symmetry,
      exact (exp b c).ump a h,
    end,
  --              φ
  --   C(a×c,  b) → C(a,  b^c)
  --
  --   (∘ k×Id_c) ↓        ↓ (∘k) commutes
  --
  --   C(x×c, b) → C(x, b^c)
  --              φ
  naturality_c :=
    begin
      intros a b h x k,
      have q : (r_product_functor c).map_hom k = product_morphism k (C.id c) := by refl,
      rw q,
      -- via uniqueness property, this is equiv. to proving
      -- h ∘ k×Id_c =  ev_b^c ∘ (h_ue ∘ k)×Id_c
      apply (exp b c).uu,
      -- by ump for h, h = ev_b^c ∘ h_ue×Id_c
      rw (exp b c).ump a h,
      rw ← C.assoc,
      apply simp_comp_right,
      -- goal is now ue_h×Id_c ∘ k×Id_c = (ue_(ev_b^c ∘ ue_h×Id_c) ∘ k)×Id_c
      -- via g×g' ∘ f×f' = (g∘f)×(g'∘f'), we change this to
      -- (ue_h ∘ k)×(Id_c ∘ Id_c) = (ue_(ev_b^c ∘ ue_h×Id_c) ∘ k)×Id_c
      rw refl_product_morphism_compose,
      apply simp_product_morphism,
      split,
      -- prove left side, ue_h ∘ k = ue_(ev_b^c ∘ ue_h×Id_c) ∘ k
      apply simp_comp_left,
      -- equivalent to ue_h = ue_(ev_b^c ∘ ue_h×Id_c), which is just ump
      rw ← (exp b c).ump a h,
      -- prove right side, trivial Id_c ∘ Id_c = Id_c
      rw C.left_id,
    end,
  naturality_d :=
    begin
      intros a b h x k,
      have q : (exponentiation_functor c).map_hom k = exp_hom c k := by refl,
      rw q,
      -- via uniqueness property, and then do some shifting around
      unfold exp_hom,
      apply (exp x c).uu,
      rw ← exp_hom,
      rw ← C.left_id (C.id c),
      rw ← refl_product_morphism_compose,
      rw C.assoc,
      rw simp_exp_hom,
      rw ← C.assoc,
      rw simp_comp_right,
      -- this is exactly wht we get from the ump
      rw ← (exp b c).ump,
    end,
  naturality_cr :=
    begin
      intros a b h x k,
      have q : (r_product_functor c).map_hom k = product_morphism k (C.id c) := by refl,
      rw q,
      rw ← C.assoc,
      rw refl_product_morphism_compose,
      rw C.left_id,
    end,
  naturality_dr :=
    begin
      intros a b h x k,
      have q : (exponentiation_functor c).map_hom k = exp_hom c k := by refl,
      rw q,
      rw C.assoc,
      rw ← simp_exp_hom,
      rw ← C.assoc,
      rw simp_comp_right,
      rw refl_product_morphism_compose,
      rw C.left_id,
    end,
}

end category_theory